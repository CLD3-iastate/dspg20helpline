---
title: "Speech-to-text"
output: html_document
---


## R Markdown

```{r}
#Load required Packages

packages <- c("rvest", "dplyr", "purrr", "readr", 
              "stringr", "magrittr", "httr", "stringr", "ggplot2",
              "ggmap", "mapview")

for (pkgs in packages){
  if(!require(pkgs, character.only = TRUE)){
    install.packages(pkgs)
    library(pkgs)
  }

}

```

```{r}

df <- read.csv("rough_data_trans.csv")

```

```{r}

df$Call_Transcript[1] # Just doing first conversation.
# \nspeaker 1:
# \nspeaker 2:

# Note the \n ... this can be used to split the text 

# Note that semicolon is our best friend here!!!!!!
```

```{r}

Text <- strsplit(df$Call_Transcript[1], "\n") #/n splitting the text... can change if you rather work with "1" and "2" rather than "speaker 1" and "speaker 2"


people_on_phone <- c("speaker 1", "speaker 2")


TidyspeechText <- lapply(Text, function(thisText){


  strsplit(thisText, ":") %>% # (1.)
    lapply(function(x){
      if(x[1] %in% people_on_phone){ # (2.)
        check <- data.frame(currently_speaking = x[1], text = paste(x[-1], collapse = ":"))
      } else{
        check <- data.frame(currently_speaking = NA, text = paste(x, collapse = ":")) # (3.)
      }
      
      return(check)
      
    }) %>%
      bind_rows %>%
        mutate(call_record = cumsum(!is.na(currently_speaking))) %>%
          group_by(call_record) %>%
            summarise(currently_speaking = currently_speaking[1], split_transcript = paste(text, collapse = "\n"))
})

TidyspeechText

# 1. Split each line by the semicolon like we mentioned above
# 2. Check if element is a speaker
# 3. If not a speaker, set speaker to NA and reset 

```

